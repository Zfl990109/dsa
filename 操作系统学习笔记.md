操作系统学习笔记
----------
- 系统启动（大体上：先读BIOS-->BIOS读加载程序-->加载程序读操作系统）
	- cpu加电后先初始化寄存器内容（跳到BIOS固件开始执行），从内存中的rom读取第一条指令
		- 系统处于实模式，地址总线只有20位，寻址空间是1MB（CS:IP = 0xf000:fff0，PC = 16*CS+IP）
		- BIOS中需要提供基本输入输出的程序、系统设置信息、开机后自检程序、系统自启动程序等（BIOS以中断调用的方式，只提供基本的I/O功能，字符显示、磁盘扇区读写、检测内存大小、键盘输入，这些功能在x86的机器上只能在实模式中使用）
			- BIOS将加载程序从磁盘的引导扇区（512字节）加载到(CS:IP = 0000:7c00)
			- 加载程序将操作系统的程序从硬盘加载到内存中，然后跳转到操作系统的起始地址
	- 具体的启动流程：BIOS-->通过主引导记录，读取主引导扇区代码-->主引导扇区代码读取活动分区的引导扇区代码-->活动分区的引导扇区代码读取文件系统的加载程序
		- CPU加电稳定后从OXFFFF0读第一条指令（跳转指令）（CS:IP = 0xf000:fff0；PC = 16*CS+IP）
			- CPU初始状态是16位实模式（CS:IP 是16位寄存器；PC = 16*CS+IP；因为左移了4位，所以最大地址空间是1MB）
		- BIOS初始化：
			- 硬件自检POST，检测系统内存和显卡等关键部件的存在和工作状态
			- 执行系统BIOS，进行系统检测，检测和配置系统中安装的即插即用设备
			- 更新CMOS中的扩展系统配置数据ESCD
			- 按指定启动顺序从软盘、硬盘或光驱启动
		- 主引导记录MBR格式：
			- 启动代码：446字节（检查分区表正确性，加载并跳到磁盘上的引导程序）
			- 硬盘分区表：64字节（描述分区状态和位置，每个分区描述信息占据16个字节）
			- 结束标志字：2字节[0X550 xAA]
		- 分区引导扇区格式：
			- 跳转指令：跳转到启动代码（与平台相关）
			- 文件卷头：文件系统描述信息
			- 启动代码：跳转到加载程序
			- 结束标志：55AA
		- 加载程序（bootloader）
			- 从文件系统读取启动配置文件
			- 选择操作系统内核列表和加载参数
			- 依据配置加载操作系统内核
	- 系统启动规范
		- BIOS
			- 固化到计算机主板上的程序（BIOS-MBE（主引导记录）、BIOS-GPT（全局唯一标识分区表）、PXE（网络启动标准））
		- UEFI
			- 在所有平台上一致的操作系统启动服务
- 中断、异常和系统调用（解决操作系统内核和外界交换的问题）
	- 内核可以执行特权指令
	- 来源：
		- 系统调用：应用程序主动向操作系统发出的服务请求
		- 异常：非法指令或其他原因导致当前指令执行失败后的处理请求（也可能是内核代码执行出现问题）
		- 中断：来自硬件设备的处理请求
	- 响应方式：
		- 中断：异步
		- 异常：同步
		- 系统调用：同步或者异步
	- 处理方式：
		- 中断：持续、对用户程序是透明的
		- 异常：杀死或者重新执行意想不到的应用程序指令
		- 系统调用：等待和持续
	- 中断处理机制
		- 硬件处理：
			- CPU初始化时设置中断使能
			- 依据内部或外部事件设置中断标志
			- 依据中断向量调用相应的中断服务例程
		- 软件
			- 现场保存（编译器）
			- 中断服务处理（服务例程）
			- 清除中断标记（服务例程）
			- 现场恢复（编译器）
	- 中断嵌套：
		- 硬件中断服务例程允许被打断，在硬件中断服务例程中需要临时禁制中断请求；中断请求会保持到CPU做出响应
		- 异常服务例程可被打断：异常服务例程执行可能出现硬件中断
		- 异常服务例程可嵌套：异常服务例程可能缺页
	- 系统调用：操作系统服务的编程接口（Win32 API、POSIX API、Java API）
		- 每个系统调用对应一个系统调用编号，系统调用接口根据系统调用号来维护表的索引
		- 系统调用接口调用内核中的系统调用功能实现，并返回系统调用的状态和结果
		- 用户不需要知道系统调用的实现，需要设置调用参数和获取返回结果
		- 系统调用和函数调用的不同：
			- 系统调用使用的 INT、IRET 指令，由于用户态和内核态的切换，需要有堆栈切换和特权级的转换
			- 函数调用使用的 CALL、RET指令，用于常规调用，没有堆栈切换
			- 系统调用比函数调用安全，但是开销大（包括引导机制、建立内核堆栈、验证参数、内核态映射到用户态的地址空间（页面映射权限更新）、内核态独立地址空间）
- X86启动顺序
	- CS = F000H, EIP = 0000FFF0H
	- 实际地址是 Base(CS) + EIP = FFFF0000H + 0000FFF0H = FFFFFFF0H,这是BIOS的EPROM所在地（长跳转指令）
	- BIOS加载存储设备上的第一个扇区的512字节（bootloader）到内存的0X7c00，然后跳转到0X7c00来执行
	- bootloader做的事情
		- 使能保护模式（从实模式的20位寻址空间到保护模式的32位寻址空间） & 段机制（分段）
		- 从硬盘上读取kernel in ELF格式的ucore kernel，并放到内存中固定位置
		- 跳转到ucore os的入口点执行，将操作权给ucore os
	- 段机制（段寄存器起到指针的作用，指向段描述符）：段寄存器中有一个段选择址（index），然后通过段选择地址找到段描述符（包括起始地址和大小），基址（Base） + 偏移量（offset即EIP）= 线性地址
		- 段描述符的数组（全局描述符表GDT，需要一个寄存器GTDR来指向全局描述符表的起始地址），由bootloader来建立（16位段寄存器中高13位放的是GDT的段选择址（index），最后两位RP表示当前段的特权级）
		- 利用特定的寄存器CR0的第0号bit置为1，则系统进入保护模式
	- 加载ELF格式的ucore os kernel
- ucore os函数调用关系：用栈来实现（为了效率高也可以通过寄存器来传递函数 & 参数返回值，不是需要保存/恢复所有的寄存器）
- GCC内联汇编：直接在c中插入汇编代码
	- 用处：调用c语言不支持的指令，用汇编在c语言中手动优化
	- 工作方式：用给定的末班和约束来生成汇编指令，在c函数内形成汇编源码
- X86中断处理过程（中断-->中断号-->IDT-->中断门-->段选择址-->Base Address-->中断服务例程）
	- 中断源：外设、软件（系统调用）、异常
	- 如何处理：每个中断或异常对应一个中断号和相应的中断服务例程（ISR）
	- 初始化中断描述符表（IDT）结合GDT来建立映射关系，中断向量表的起始地址需要利用寄存器IDTR来保存，因此需要操作系统来建立
		- 中断门（陷阱门）：主要是段选择址、偏移量（offset），凭借这两个信息可以知道中断服务例程的起始地址
	- 流程:
		- 当产生中断时，会得到一个中断向量号
		- 然后cpu根据中断向量号来查找中断描述符表（IDT），得到一个IDT的一个index，找到对应的中断门（陷阱门）
		- 然后根据中断门中的段选择址来找到对应的段描述符，并得到基址（Base Address）
		- 根据Base Address 和中断门中的偏移量（offset）来得到中断服务例程的起始地址
	- 中断需要保存现场和恢复现场，对应不同特权级的中断，处理方式不同（硬件自动完成）
		- 段选择址的最后两位描述了特权级，当最后两位为0，表示内核态；最低两位是3，则为用户态。
		- 内核态的中断仍然在内核态（栈相同，只不过压入了一些信息，例如地址、状态等），用户态的中断会跳到内核态来进行处理（栈不同，内核态的栈还需要保存用户态使用的栈的地址）
	- 通过中断实现系统调用
		- 用户通过系统调用访问os内核服务
		- 实现方式：指定中断号，使用Trap