操作系统学习笔记
----------
第一章：系统启动
----------

- 系统启动（大体上：先读BIOS-->BIOS读加载程序-->加载程序读操作系统）
	- cpu加电后先初始化寄存器内容（跳到BIOS固件开始执行），从内存中的rom读取第一条指令
		- 系统处于实模式，地址总线只有20位，寻址空间是1MB（CS:IP = 0xf000:fff0，PC = 16*CS+IP）
		- BIOS中需要提供基本输入输出的程序、系统设置信息、开机后自检程序、系统自启动程序等（BIOS以中断调用的方式，只提供基本的I/O功能，字符显示、磁盘扇区读写、检测内存大小、键盘输入，这些功能在x86的机器上只能在实模式中使用）
			- BIOS将加载程序从磁盘的引导扇区（512字节）加载到(CS:IP = 0000:7c00)
			- 加载程序将操作系统的程序从硬盘加载到内存中，然后跳转到操作系统的起始地址
	- 具体的启动流程：BIOS-->通过主引导记录，读取主引导扇区代码-->主引导扇区代码读取活动分区的引导扇区代码-->活动分区的引导扇区代码读取文件系统的加载程序
		- CPU加电稳定后从OXFFFF0读第一条指令（跳转指令）（CS:IP = 0xf000:fff0；PC = 16*CS+IP）
			- CPU初始状态是16位实模式（CS:IP 是16位寄存器；PC = 16*CS+IP；因为左移了4位，所以最大地址空间是1MB）
		- BIOS初始化：
			- 硬件自检POST，检测系统内存和显卡等关键部件的存在和工作状态
			- 执行系统BIOS，进行系统检测，检测和配置系统中安装的即插即用设备
			- 更新CMOS中的扩展系统配置数据ESCD
			- 按指定启动顺序从软盘、硬盘或光驱启动
		- 主引导记录MBR格式：
			- 启动代码：446字节（检查分区表正确性，加载并跳到磁盘上的引导程序）
			- 硬盘分区表：64字节（描述分区状态和位置，每个分区描述信息占据16个字节）
			- 结束标志字：2字节[0X550 xAA]
		- 分区引导扇区格式：
			- 跳转指令：跳转到启动代码（与平台相关）
			- 文件卷头：文件系统描述信息
			- 启动代码：跳转到加载程序
			- 结束标志：55AA
		- 加载程序（bootloader）
			- 从文件系统读取启动配置文件
			- 选择操作系统内核列表和加载参数
			- 依据配置加载操作系统内核
	- 系统启动规范
		- BIOS
			- 固化到计算机主板上的程序（BIOS-MBE（主引导记录）、BIOS-GPT（全局唯一标识分区表）、PXE（网络启动标准））
		- UEFI
			- 在所有平台上一致的操作系统启动服务
- 中断、异常和系统调用（解决操作系统内核和外界交换的问题）
	- 内核可以执行特权指令
	- 来源：
		- 系统调用：应用程序主动向操作系统发出的服务请求
		- 异常：非法指令或其他原因导致当前指令执行失败后的处理请求（也可能是内核代码执行出现问题）
		- 中断：来自硬件设备的处理请求
	- 响应方式：
		- 中断：异步
		- 异常：同步
		- 系统调用：同步或者异步
	- 处理方式：
		- 中断：持续、对用户程序是透明的
		- 异常：杀死或者重新执行意想不到的应用程序指令
		- 系统调用：等待和持续
	- 中断处理机制
		- 硬件处理：
			- CPU初始化时设置中断使能
			- 依据内部或外部事件设置中断标志
			- 依据中断向量调用相应的中断服务例程
		- 软件
			- 现场保存（编译器）
			- 中断服务处理（服务例程）
			- 清除中断标记（服务例程）
			- 现场恢复（编译器）
	- 中断嵌套：
		- 硬件中断服务例程允许被打断，在硬件中断服务例程中需要临时禁制中断请求；中断请求会保持到CPU做出响应
		- 异常服务例程可被打断：异常服务例程执行可能出现硬件中断
		- 异常服务例程可嵌套：异常服务例程可能缺页
	- 系统调用：操作系统服务的编程接口（Win32 API、POSIX API、Java API）
		- 每个系统调用对应一个系统调用编号，系统调用接口根据系统调用号来维护表的索引
		- 系统调用接口调用内核中的系统调用功能实现，并返回系统调用的状态和结果
		- 用户不需要知道系统调用的实现，需要设置调用参数和获取返回结果
		- 系统调用和函数调用的不同：
			- 系统调用使用的 INT、IRET 指令，由于用户态和内核态的切换，需要有堆栈切换和特权级的转换
			- 函数调用使用的 CALL、RET指令，用于常规调用，没有堆栈切换
			- 系统调用比函数调用安全，但是开销大（包括引导机制、建立内核堆栈、验证参数、内核态映射到用户态的地址空间（页面映射权限更新）、内核态独立地址空间）
- X86启动顺序
	- CS = F000H, EIP = 0000FFF0H
	- 实际地址是 Base(CS) + EIP = FFFF0000H + 0000FFF0H = FFFFFFF0H,这是BIOS的EPROM所在地（长跳转指令）
	- BIOS加载存储设备上的第一个扇区的512字节（bootloader）到内存的0X7c00，然后跳转到0X7c00来执行
	- bootloader做的事情
		- 使能保护模式（从实模式的20位寻址空间到保护模式的32位寻址空间） & 段机制（分段）
		- 从硬盘上读取kernel in ELF格式的ucore kernel，并放到内存中固定位置
		- 跳转到ucore os的入口点执行，将操作权给ucore os
	- 段机制（段寄存器起到指针的作用，指向段描述符）：段寄存器中有一个段选择址（index），然后通过段选择地址找到段描述符（包括起始地址和大小），基址（Base） + 偏移量（offset即EIP）= 线性地址
		- 段描述符的数组（全局描述符表GDT，需要一个寄存器GTDR来指向全局描述符表的起始地址），由bootloader来建立（16位段寄存器中高13位放的是GDT的段选择址（index），最后两位RP表示当前段的特权级）
		- 利用特定的寄存器CR0的第0号bit置为1，则系统进入保护模式
	- 加载ELF格式的ucore os kernel
- ucore os函数调用关系：用栈来实现（为了效率高也可以通过寄存器来传递函数 & 参数返回值，不是需要保存/恢复所有的寄存器）
- GCC内联汇编：直接在c中插入汇编代码
	- 用处：调用c语言不支持的指令，用汇编在c语言中手动优化
	- 工作方式：用给定的末班和约束来生成汇编指令，在c函数内形成汇编源码
- X86中断处理过程（中断-->中断号-->IDT-->中断门-->段选择址-->Base Address-->中断服务例程）
	- 中断源：外设、软件（系统调用）、异常
	- 如何处理：每个中断或异常对应一个中断号和相应的中断服务例程（ISR）
	- 初始化中断描述符表（IDT）结合GDT来建立映射关系，中断向量表的起始地址需要利用寄存器IDTR来保存，因此需要操作系统来建立
		- 中断门（陷阱门）：主要是段选择址、偏移量（offset），凭借这两个信息可以知道中断服务例程的起始地址
	- 流程:
		- 当产生中断时，会得到一个中断向量号
		- 然后cpu根据中断向量号来查找中断描述符表（IDT），得到一个IDT的一个index，找到对应的中断门（陷阱门）
		- 然后根据中断门中的段选择址来找到对应的段描述符，并得到基址（Base Address）
		- 根据Base Address 和中断门中的偏移量（offset）来得到中断服务例程的起始地址
	- 中断需要保存现场和恢复现场，对应不同特权级的中断，处理方式不同（硬件自动完成）
		- 段选择址的最后两位描述了特权级，当最后两位为0，表示内核态；最低两位是3，则为用户态。
		- 内核态的中断仍然在内核态（栈相同，只不过压入了一些信息，例如地址、状态等），用户态的中断会跳到内核态来进行处理（栈不同，内核态的栈还需要保存用户态使用的栈的地址）
	- 通过中断实现系统调用
		- 用户通过系统调用访问os内核服务
		- 实现方式：指定中断号，使用Trap


第二章：物理内存管理（基本的要求：分配和释放）
----------

- 连续地址分配
	- 内存层次：CPU两级缓存（硬件管理控制）--------(高速缓存未命中)---->内存（操作系统控制）--------(缺页)------>外存(虚拟内存)（操作系统控制）
		- 内存：以一个字节为单位，每个字节都有一个对应的地址（物理地址）
		- 外存：（磁盘）对扇区进行访问，每个扇区是512个字节
		- 存储控制单元（MMU）（抽象、保护、共享、虚拟化）：把逻辑地址空间转换成物理地址空间，把线性的物理地址空间抽象成逻辑地址空间，并且使得每个进程具有独立的空间，只能访问自己的空间，并且还要保证共享，虚拟化得到更大的地址空间
			- 实现方式：（高度依赖硬件，与计算机存储架构高耦合）
				- 重定位（程序需要的整块地址搬移）：
				- 分段（代码段、数据段、堆栈相对分开）：
				- 分页（最基本的连续区域）：
				- 虚拟存储：
- 地址空间和地址生成
	- 地址空间的定义：
		- 物理地址空间————硬件支持的地址空间（起始为0，直到max）
		- 逻辑地址空间————在CPU运行的进程看到的地址空间
	- 逻辑地址生成：（编译、汇编、链接、程序加载）
		- 编译时：假设起始地址已知，可以直接写死，一旦改变则必须重新编译
		- 加载时：编译时如果起始位置不知道，则必须要编译器生成重定位的代码，加载时候会变成绝对地址
		- 执行时：执行时代码存储的位置可以移动，需要地址转换（映射）硬件支持
	- 地址生成过程：
		- ALU需要知道逻辑地址
		- MMU完成逻辑地址转换成物理地址
		- CPU控制逻辑：总线发送物理地址请求
		- 内存：发送物理地址的内容给CPU或接受CPU数据给物理地址
		- 操作系统：建立逻辑地址LA和物理地址PA的映射表
		- 首先CPU会得到逻辑地址，然后检查偏移量是否超过了段的最大长度，如果小于最大长度，则根据段基址和偏移量得到物理地址，然后去访问物理地址
- 连续内存分配和内存碎片
	- 连续内存分配：给进程分配一块不小于指定大小的物理内存区域
	- 内存碎片：
		- 外部碎片：分配单元之间未使用的内存
		- 内部碎片：分配给进程的内部的未使用的内存
	- 动态分区分配：（指定大小，大小可变）当程序被加载执行时，分配一个进程指定的大小可变的分区（块、内存块）
	- 分区的地址是连续的
	- 操作系统需要的数据结构：所有进程的已分配分区、空闲分区的位置和大小
	- 动态分区策略：
		- 最先匹配：分配n个字节，找到第一个比n大的空闲块；原理 & 实现：空闲地址分区按照地址顺序排列，分配时从前往后找到第一个合适的分区；释放分区时，检查是否与邻近空闲分区合并（优点：简单、高地址空间有大块的空闲分区；缺点：外部碎片，分配大块时比较慢）
		- 最佳匹配：查找并且使用不小于n的最小空闲分区；原理 & 实现：空闲分区按照大小排序，从小往大查找，找到第一个比n大的；释放时，查找是否可以与邻近的空闲分区合并（由于不是按地址排序，因此时间较长），并且需要排序。（优点：大部分分配的尺寸较小时，效果较好、避免大块分区被拆分、可减小外部碎片的大小、相对简单；缺点：外部碎片、释放分区慢、小碎片无法使用）
		- 最差排序：查找并使用不小于n字节的最大空闲分区；原理 & 实现：空闲分区从大到小排列，分配时，选最大的；释放时，检查与邻近分区是否可以合并，并且在插入空闲分区列表时需要排序。（优点：中等大小的分块较多时，效果最后、避免出现太多小碎片；缺点：释放分区慢、外部碎片、容易破坏大的空闲分区，分配大块分区较困难）
- 碎片整理
	- 通过调整进程占用的分区位置，来避免或减少分区碎片
	- 碎片紧凑：
		- 通过移动分配给进程的内存分区，以合并外部碎片，要求所有程序可以动态重定位，在进程处于等待的状态移动，并且考虑移动的开销
	- 分区对换：通过抢占处于等待状态的进程的地址空间，将等待状态的进程的数据存放到外存中
- 伙伴系统（连续分配的实例）
	- 规定整个可分配的分区大小为2的u次方，若空闲块较大，则二等分，重复此过程
	- 数据结构：空闲块按照大小和起始地址组织成二维数组
	- 初始状态：只有一个大小为2的u次方的空闲块
	- 释放过程：释放的空闲块放入空闲分区数组，合并条件：相邻的空闲块大小必须相对，低地址空闲块的起始地址必须是2的整数次方
- 连续分配的缺点：分配给程序的内存必须连续、存在外碎片和内碎片、内存分配的动态修改困难、内存利用率低
- 非连续内存分配：提高内存利用效率和管理灵活性（允许程序使用非连续的物理地址空间、允许共享代码和数据、支持动态加载和动态链接）
	- 需要解决的问题：虚拟地址到物理地址的转换（软件实现：灵活、开销大；硬件实现：够用，开销小）、硬件辅助机制（如何选择非连续分配的内存分块大小）
	- 段式存储管理：分块较大，段为基本单位，段内连续，不同段不连续
		- 段地址空间：进程的段地址空间为多个段组成（主代码段、子模块代码块、公用库代码段、堆栈段、堆数据、初始化数据段、符号表等）实现更细粒度的分离和共享
		- 逻辑上连续，物理上不连续
		- 段访问机制：段表示访问方式和存储数据等属性相同的一段地址空间，对应一个连续的内存块，若干个段组成进程逻辑地址空间
			- 段访问：逻辑地址由二元组（s，addr）表示，s————段号，addr————段内偏移
			- 硬件实现：根据段号查找段描述符表，得到相应的段描述符，MMU检查段长度和偏移量，看是否越界，然后MMU利用段基址和偏移量找到实际的物理地址
	- 页式存储管理：分块较小，页为基本单位，业内连续，不同页之间不连续
		- 概念：把物理地址空间分为大小相同的基本分配单位（页帧，大小为2的n次方）；逻辑地址空间也划分成相同大小的基本分配单位（页面，帧和页的大小必须相同）；
		- 页面到页帧的转换（逻辑地址和物理地址的转换）：页表中保存转换关系，然后MMU和TLB来实现转换
		- 帧：二元组（f，o）f————帧号，o————帧内偏移（s位，每帧共有2^s字节），物理地址 = f*2^s + o；
		- 页：页内偏移 = 帧内偏移，通常页号 ！= 帧号；二元组（p，o）p————页号，o————页内偏移；虚拟地址 = p*2^s + o；
		- 页式存储管理的地址转换：（页到帧的映射）逻辑地址中页号连续，物理地址帧号不连续，页号 ！= 帧号；
		- 页表：逻辑地址（p，o），从业表中找到p对应的f（页表基址加上p作为下标来直接查找），然后得到物理地址 = f*2^s + o；
			- 页表概述：每个进程都有一个页表，每个页面对应一个页表项，随着进程运行状态而动态变化，页表的起始地址存放在页表基址寄存器中（PTBR），页表项包括：帧号f，页表项标志（存在位、修改位、引用位）
		- 页式存储管理机制的性能问题：
			- 访问一个内存单元需要2次内存访问，第一次获取页表项，第二次访问数据，利用缓存（将访问过的页存入到cache中，说不定下次访问的数据在同一页中）来加快访问
			- 页表大小问题，页表可能非常大（利用多级页表有效减少整个页表长度）
	- 快表：把近期访问过得页表项缓存到CPU中，TLB（容量小）使用关联存储实现，具备快速访问性能，如果TLB命中，物理页号可以很快被获取；若TLB未命中，则进行二次访问，对应的表项会被会被更新到TLB中
	- 多级页表：通过间接引用将页号分成K级，（p1, p2, p3, pk, o），建立页表树，减少每一级页表的长度，节省空间
	- 反置页表（大地址空间系统的多级页表显得繁琐，并且逻辑地址空间增长速度快于物理地址空间）
			- 思路：不让页表与逻辑地址空间的大小对应，而让其与物理地址空间大小相对于
			- 地址转换：对进程标识和页号进行Hash，并在反置页表中进行查找，检查进程ID和逻辑页号是否与Hash之前的一致，如果不同则产生冲突，并检查下一项
	- 页寄存器：每个帧与一个页寄存器关联，内容包括：使用位（此帧是否被进程占用）、占用页号（对应页号p）、保护位（约定这一页的访问方式）（优点：页表大小相对于物理内存而言很小，页表大小与逻辑地址空间大小无关；缺点：需要依据帧号找页号，需要在页寄存器中进行搜索逻辑地址中的页号）
		- 页寄存器地址转换：把逻辑地址进行Hash映射，在快表中查找对应的页表项，有冲突时遍历冲突项链表，查找失败时，产生异常（快表的限制：容量、功耗限制）
	- 段页式存储管理：段式存储在内存保护方面有优势，页式存储在内存利用和优化转移到后备存储方面有优势
		- （s，p，o）s————段号，p————页号，o————页内偏移；先根据段号s查找相应的段表项，然后在段s的页表中查找对应的物理页帧号，然后加上页内偏移得到物理地址
		- 方便实现共享，通过指向相同的页表基址，实现进程间的段共享
第三章：虚拟存储
----------
- 解决计算机内存空间不够用的方法
	- 覆盖（应用程序手动把需要的指令和数据保存到内存中）：发生在进程内部
		- 目标：在较小的可用内存中运行较大的程序
		- 方法：依据程序逻辑结构，将程序划分为若干个功能相对独立的模块，将不会同时执行的模块共享一块内存区域
		- 必要部分（常用功能）的代码和数据常驻内存
		- 可选部分（不常用功能）放在其他程序模块中，只在需要使用到时装入内存
		- 不存在调用关系的模块可以相互覆盖，共用同一块内存区域
		- 缺点：增加变成困难，需要程序员划分功能模块，确定模块间的覆盖关系，增加了执行时间（从外存中读模块，时间换空间）
	- 交换（操作系统自动把暂时不能执行的程序保存到外存中）：发生在进程之间
		- 目标：增加正在运行或需要运行的程序的内存
		- 实现方法：可将暂时不能运行的程序放到外存，整个进程的地址空间为换入换出的基本单位
		- 面临的问题：交换的时机（只当内存空间不够或有不够的可能时换出）、交换区域的大小（存放所有暂停的用户进程的所有内存映像的拷贝）、程序换入时的重定位（采用动态地址映射办法）
	- 虚拟存储（在有限容量的内存中，以页为单位自动装入更大的程序）
		- 在非连续存储内存分配的基础上，可以把一部分内容放到外存中，让内存空间更大（主要是根据局部性原理，把经常访问的放到内存中，不经常访问的放到外存中）
		- 局部性原理：程序在执行过程的一个较短时期，所执行的指令地址和指令的操作数地址，分别局限于一定区域（时间局部性、空间局部性、分支局部性）
		- 目标：只把部分程序放到内存中，从而运行比物理内存大的程序（操作系统自动完成），实现进程在内存与外存之间的交换，从而获得更多的空闲内存空间
		- 原理：装在程序时，只将当前指令执行需要的部分页面或者段装入内存，指令执行中需要的指令或数据不存在（称为缺页或缺段）时，处理器通知操作系统将相应的页面或者段调入内存，操作系统监控运行状态，将内存中暂时不用的页面或段保存到外存中
		- 实现方式：虚拟页式存储、虚拟段式存储
		- 特点：不连续（物理地址分配非连续、虚拟地址空间非连续）、大用户空间（提供给用户的虚拟内存大于实际的物理内存）、部分交换（只对部分虚拟地址空间进行换入换出）
		- 支持技术：硬件（页式或短时存储中的地址转换机制、操作系统管理内存和外存间页面或段的换入和换出）
	- 虚拟页式存储
		- 在页式存储管理的基础上，增加请求调页和页面置换
		- 思路：当用户程序要装载到内存运行时，只装入部分页面，就启动程序运行，当进程在运行时发现有需要的代码或数据不在内存时，则向系统发出缺页异常请求，操作系统在处理缺页异常时，将外存中相应的页面调入内存，使得进程能够继续运行
		- 虚拟页式存储中的页表项结构：逻辑页号 + 标志位 + 物理页帧号
			- 标志位：驻留位（表示该页是否在内存中）、修改位（表示在内存中的该页是否被修改过）、访问位（表示该页面是否被访问过）、保护位（表示该页允许的访问方式）
	- 缺页异常：发现需要用到的数据或指令所在的页表项不在物理内存中，则会产生缺页异常
		- 操作系统执行缺页异常服务例程，查找外存中的页面，如果物理内存中此时有空闲的页面，则将外存中的页面直接复制，然后修改页表项，然后重新开始执行指令（如果物理内存没有空闲页面，则依据页面置换算法选择将被替换的物理页帧f（对应逻辑页q）,如果q被修改过，则写回到外存中，修改q的页表项中的驻留位为0，将需要访问的页面装入到f，然后修改页表项驻留位为1，物理页帧号为f，重新执行产生缺页异常的指令）
		- 在何处找到未被映射的页：直接使用一个分区做交换区，采用特殊格式存储未被映射的页面（文件格式）
		- 虚拟页式存储中的外存选择：代码段————可执行二进制文件、动态加载的共享库程序段————动态调用的库文件、其他段————交换区
		- 有效存储访问时间：EAT = 访存时间 * （1 - p）+ 缺页异常处理时间（如果存在页修改，则还会产生开销） * 缺页率p 
